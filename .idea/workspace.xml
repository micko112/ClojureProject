<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="4d338447-6f3a-43e8-ab8c-95e214f36644" name="Changes" comment="Change to clojure.test, done 2 tests">
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_bhauman_spell_spec_0_1_2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_cognitect_transit_clj_1_0_324.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_cognitect_transit_java_1_0_343.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_datatype_jackson_datatype_jsr310_2_17_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_googlecode_json_simple_json_simple_1_1_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__commons_fileupload_1_4.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__crypto_equality_1_0_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__crypto_random_1_2_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__expound_0_9_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__fi_metosin_reitit_openapi_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__hiccup_2_0_0_RC2.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__javax_servlet_javax_servlet_api_3_1_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__javax_xml_bind_jaxb_api_2_3_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__lambdaisland_deep_diff_0_0_47.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__meta_merge_1_0_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_jsonista_0_3_9.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_muuntaja_0_6_10.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_core_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_dev_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_frontend_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_http_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_interceptors_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_malli_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_middleware_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_ring_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_schema_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_sieppari_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_spec_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_swagger_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_reitit_swagger_ui_0_7_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_ring_swagger_ui_5_9_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_schema_tools_0_13_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_sieppari_0_0_0_alpha13.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__metosin_spec_tools_0_10_7.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_eclipse_jetty_jetty_http_9_4_48_v20220622.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_eclipse_jetty_jetty_io_9_4_48_v20220622.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_eclipse_jetty_jetty_server_9_4_48_v20220622.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_eclipse_jetty_jetty_util_9_4_48_v20220622.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_javassist_javassist_3_18_1_GA.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__org_msgpack_msgpack_0_6_12.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__prismatic_schema_1_1_12.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_anti_forgery_1_3_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_codec_1_2_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_core_1_9_6.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_defaults_0_3_4.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_headers_0_3_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_jetty_adapter_1_9_6.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_servlet_1_9_6.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__ring_ring_ssl_0_3_0.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__tech_droit_clj_diff_1_0_1.xml" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/project/web.clj" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/web/server.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_annotations_2_6_0.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_annotations_2_17_1.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_core_2_6_6.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_core_2_17_1.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_databind_2_6_6.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/libraries/Leiningen__com_fasterxml_jackson_core_jackson_databind_2_17_1.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/.nrepl-port" beforeDir="false" afterPath="$PROJECT_DIR$/.nrepl-port" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/ProjectV1.iml" beforeDir="false" afterPath="$PROJECT_DIR$/ProjectV1.iml" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/project.clj" beforeDir="false" afterPath="$PROJECT_DIR$/project.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/project/leaderboard.clj" beforeDir="false" afterPath="$PROJECT_DIR$/src/project/leaderboard.clj" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/classes/META-INF/maven/ProjectV1/ProjectV1/pom.properties" beforeDir="false" afterPath="$PROJECT_DIR$/target/classes/META-INF/maven/ProjectV1/ProjectV1/pom.properties" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/repl-port" beforeDir="false" afterPath="$PROJECT_DIR$/target/repl-port" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" beforeDir="false" afterPath="$PROJECT_DIR$/target/stale/leiningen.core.classpath.extract-native-dependencies" afterDir="false" />
    </list>
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="Clojure Test Namespace" />
        <option value="Clojure Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="GitHubPullRequestSearchHistory">{
  &quot;lastFilter&quot;: {
    &quot;state&quot;: &quot;OPEN&quot;,
    &quot;assignee&quot;: &quot;micko112&quot;
  }
}</component>
  <component name="GithubPullRequestsUISettings">{
  &quot;selectedUrlAndAccountId&quot;: {
    &quot;url&quot;: &quot;https://github.com/micko112/ClojureProject.git&quot;,
    &quot;accountId&quot;: &quot;3764571a-842a-40c7-838d-20632f3769b4&quot;
  }
}</component>
  <component name="HighlightingSettingsPerFile">
    <setting file="file://$PROJECT_DIR$/src/project/db.clj" root0="FORCE_HIGHLIGHTING" />
  </component>
  <component name="ProjectColorInfo">{
  &quot;associatedIndex&quot;: 5
}</component>
  <component name="ProjectId" id="37ZsZpPnuy4tgd50LQGXH7cfGlR" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent">{
  &quot;keyToString&quot;: {
    &quot;Clojure REPL.REPL for ProjectV1.executor&quot;: &quot;Run&quot;,
    &quot;ModuleVcsDetector.initialDetectionPerformed&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
    &quot;RunOnceActivity.git.unshallow&quot;: &quot;true&quot;,
    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,
    &quot;clojure.test.Test project.api-test/delta-test.executor&quot;: &quot;Run&quot;,
    &quot;clojure.test.Test project.api-test/leaderboard-rank-ties-test.executor&quot;: &quot;Run&quot;,
    &quot;cursive.last.file.extension.C\\:/xampp/htdocs/Clojure/Clojure for Brave and True/ProjectV1/src&quot;: &quot;clj&quot;,
    &quot;cursive.last.file.extension.C\\:/xampp/htdocs/Clojure/Clojure for Brave and True/ProjectV1/test&quot;: &quot;clj&quot;,
    &quot;git-widget-placeholder&quot;: &quot;main&quot;,
    &quot;last_opened_file_path&quot;: &quot;C:/xampp/htdocs/Clojure/Clojure for Brave and True/ProjectV1/project.clj&quot;,
    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.lookFeel&quot;,
    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
  },
  &quot;keyToStringList&quot;: {
    &quot;GitStage.ChangesTree.GroupingKeys&quot;: [
      &quot;directory&quot;,
      &quot;module&quot;,
      &quot;repository&quot;
    ]
  }
}</component>
  <component name="RecentsManager">
    <key name="MoveFile.RECENT_KEYS">
      <recent name="C:\xampp\htdocs\Clojure\Clojure for Brave and True\ProjectV1\src\playground" />
    </key>
  </component>
  <component name="ReplState" timestamp="1769377019115">{:repl-history {:ide [], :local [{:command &quot;(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (if-let [user (first user-left)]\n          (let [user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     prev-xp user-xp\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n\n          )))))&quot;, :offset 1156, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (if-let [user (first user-left)]\n          (let [user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     user-xp\n                     (inc count)\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n\n          )))))&quot;, :offset 1181, :ns &quot;project.leaderboard&quot;} {:command &quot;(leaderboard-rank-ties-2 (d/db conn) :all (LocalDate/now) )&quot;, :offset 56, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (if-let [user (first user-left)]\n          (let [user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     user-xp\n                     (inc count)\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n          result\n\n          )))))&quot;, :offset 1198, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n;leadreboard for all users\n; (db/get-all-users (d/db conn))\n(defn\n  leaderboard\n  \&quot;users Leaderboard by earned XP\&quot;\n  [users]\n  (sort-by :user/xp desc (map first users)))\n\n(defn leaderboard [db period date]\n  (sort-by :user/xp &gt; (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           (db/get-all-users db)))\n    )\n\n(defn leaderboard-rank [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (map-indexed (fn [idx itm] (assoc itm\n                                 :rank (inc idx))) sorted-users-with-xp)\n\n    ))\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (if-let [user (first user-left)]\n          (let [user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     user-xp\n                     (inc count)\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n          result\n          )))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 3845, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))&quot;, :offset 429, :ns &quot;project.leaderboard&quot;} {:command &quot;(leaderboard-rank-ties-2)&quot;, :offset 24} {:command &quot;(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (let [user (first user-left)\n              user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     user-xp\n                     (inc count)\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (conj result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n          result\n          ))))&quot;, :offset 1195, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-rank-ties-2 [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [user-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           count 0\n           ]\n      (if (empty? user-left)\n        result\n        (let [user (first user-left)\n              user-xp (:user/xp user)]\n            (if (= user-xp prev-xp)\n              (recur (rest user-left)\n                     (conj result (assoc user :rank current-rank))\n                     current-rank\n                     user-xp\n                     (inc count)\n                    )\n              (let [new-rank (+ current-rank count)]\n                (recur (rest user-left)\n                       (conj result (assoc user :rank new-rank))\n                       new-rank\n                       user-xp\n                       1))))\n          \n          ))))&quot;, :offset 1189, :ns &quot;project.leaderboard&quot;} {:command &quot;(leaderboard-rank-ties-2 (d/db conn) :all (LocalDate/now))&quot;, :offset 58, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n;leadreboard for all users\n; (db/get-all-users (d/db conn))\n(defn\n  leaderboard\n  \&quot;users Leaderboard by earned XP\&quot;\n  [users]\n  (sort-by :user/xp desc (map first users)))\n\n(defn leaderboard [db period date]\n  (sort-by :user/xp &gt; (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           (db/get-all-users db)))\n    )\n\n(defn leaderboard-rank [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (map-indexed (fn [idx itm] (assoc itm\n                                 :rank (inc idx))) sorted-users-with-xp)\n\n    ))\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n\n(defn leaderoard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn [{:user/keys [username rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             {:user/username username\n              :delta (- old-r new-r)}))\n         (keys new-ranks))))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 3285, :ns &quot;project.core&quot;} {:command &quot;(map (fn [{:user/keys [username rank]}]\n  [username rank]) (leaderboard (d/db conn) :all (LocalDate/now)))&quot;, :offset 103, :ns &quot;project.leaderboard&quot;} {:command &quot;(map (fn [{:user/keys [username rank]}]\n  [username]) (leaderboard (d/db conn) :all (LocalDate/now)))&quot;, :offset 99, :ns &quot;project.leaderboard&quot;} {:command &quot;(map (fn [{:user/keys [username rank]}]\n  {username rank}) (leaderboard (d/db conn) :all (LocalDate/now)))&quot;, :offset 56, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))&quot;, :offset 1128, :ns &quot;project.leaderboard&quot;} {:command &quot;(map (fn [{:user/keys [username rank]}]\n  {username rank}) (leaderboard-rank-ties (d/db conn) :all (LocalDate/now)))&quot;, :offset 36, :ns &quot;project.leaderboard&quot;} {:command &quot;(map (fn [{:user/keys [username rank]}]\n  [username rank]) (leaderboard-rank-ties (d/db conn) :all (LocalDate/now)))&quot;, :offset 56, :ns &quot;project.leaderboard&quot;} {:command &quot;(into {} (map (fn [{:user/keys [username rank]}]\n  [username rank]) (leaderboard-rank-ties (d/db conn) :all (LocalDate/now))))&quot;, :offset 7, :ns &quot;project.leaderboard&quot;} {:command &quot;(into {} (map (fn [{:user/keys [username] :keys [rank]}]\n  [username rank]) (leaderboard-rank-ties (d/db conn) :all (LocalDate/now))))&quot;, :offset 53, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderoard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             {:user/username username\n              :delta (- old-r new-r)}))\n         (keys new-ranks))))&quot;, :offset 588, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n\n\n\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n\n(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             {:user/username username\n              :delta (- old-r new-r)}))\n         (keys new-ranks))))\n\n(defn leaderboard [db period date]\n  (let [today (LocalDate/now)\n                        yesterday (.minusDays today 1)\n                        db (d/db conn)\n                        old-lb (leaderboard-rank-ties db period today)\n                        new-lb (leaderboard-rank-ties db period yesterday)\n                        delta (leaderboard-delta old-lb new-lb)\n                        ]\n                    (map (fn [{:user/keys [username]}])))) \n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 2794, :ns &quot;project.leaderboard&quot;} {:command &quot;(db/add-activity! conn \&quot;Toda\&quot; :hobby 30 2)&quot;, :offset 41, :ns &quot;project.leaderboard&quot;} {:command &quot;(let [today (LocalDate/now)\n      yesterday (.minusDays today 1)\n      db (d/db conn)\n      old-lb (leaderboard-rank-ties db :daily today)\n      new-lb (leaderboard-rank-ties db :daily yesterday)\n      delta (leaderboard-delta old-lb new-lb)\n      ]\n delta)&quot;, :offset 256, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard [db period date]\n  (let [today (LocalDate/now)\n                        yesterday (.minusDays today 1)\n                        db (d/db conn)\n                        old-lb (leaderboard-rank-ties db period today)\n                        new-lb (leaderboard-rank-ties db period yesterday)\n                        delta (leaderboard-delta old-lb new-lb)\n                        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                                  [username delta])\n                                                delta))\n                        ]\n                    (map (fn [user-rank]\n                           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n                         new-lb)))&quot;, :offset 784, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard [db period date]\n  ()\n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))&quot;, :offset 741, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard [db period date]\n  \n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))&quot;, :offset 739, :ns &quot;project.leaderboard&quot;} {:command &quot;(leaderboard (d/db conn) :daily (LocalDate/now))&quot;, :offset 46, :ns &quot;project.leaderboard&quot;} {:command &quot;(leaderboard (d/db conn) :weekly (LocalDate/now))&quot;, :offset 32, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n\n\n\n\n&quot;, :offset 702, :ns &quot;project.core&quot;} {:command &quot;(lb/leaderboard-delta old-lb new-lb )&quot;, :offset 37, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (lb/leaderboard-delta old-lb new-lb )\n  =&gt; ({:user/username \&quot;A\&quot;, :delta -1} {:user/username \&quot;B\&quot;, :delta 1} {:user/username \&quot;C\&quot;, :delta 0})\n\n)&quot;, :offset 149, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; {\&quot;A\&quot; -1\n      \&quot;B\&quot; 1\n      \&quot;C\&quot; 0}\n\n)&quot;, :offset 109, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; ({:delta -1 :user/username \&quot;A\&quot;}\n      {:delta 1 :user/username \&quot;B\&quot;}\n      {:delta 0 :user/username \&quot;C\&quot;})\n\n)&quot;, :offset 181, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; {{:delta -1 :user/username \&quot;A\&quot;}\n      {:delta 1 :user/username \&quot;B\&quot;}\n      {:delta 0 :user/username \&quot;C\&quot;}}\n\n)&quot;, :offset 181, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:delta -1 :user/username \&quot;A\&quot;}\n      {:delta 1 :user/username \&quot;B\&quot;}\n      {:delta 0 :user/username \&quot;C\&quot;}\n      ]\n\n)&quot;, :offset 188, :ns &quot;project.api-test&quot;} {:command &quot;(fact\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:delta -1 :user/username \&quot;A\&quot;}\n      {:delta 1 :user/username \&quot;B\&quot;}\n      {:user/username \&quot;C\&quot; :delta 0 }]\n\n)&quot;, :offset 182, :ns &quot;project.api-test&quot;} {:command &quot;(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n   ])&quot;, :offset 128, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n      (let [new-lb [{:user/username \&quot;A\&quot; :user/xp 300}\n                    {:user/username \&quot;B\&quot; :user/xp 200}\n                    {:user/username \&quot;C\&quot; :user/xp 150}\n                    {:user/username \&quot;D\&quot; :user/xp 150}\n                    ]])\n      (let [delta (lb/leaderboard-delta old-lb new-lb)]\n        delta)\n      =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n          {:user/username \&quot;B\&quot; :delta 1 }\n          {:user/username \&quot;C\&quot; :delta 0 }]\n      )&quot;, :offset 471, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n      (let [new-lb [{:user/username \&quot;A\&quot; :user/xp 300}\n                    {:user/username \&quot;B\&quot; :user/xp 200}\n                    {:user/username \&quot;C\&quot; :user/xp 150}\n                    {:user/username \&quot;D\&quot; :user/xp 150}\n                    ]]\n        (let [delta (lb/leaderboard-delta old-lb new-lb)]\n          delta))\n     \n      =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n          {:user/username \&quot;B\&quot; :delta 1 }\n          {:user/username \&quot;C\&quot; :delta 0 }]\n      )&quot;, :offset 481, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n        (let [delta (lb/leaderboard-delta old-lb new-lb)]\n          delta))&quot;, :offset 103, :ns &quot;project.api-test&quot;} {:command &quot;(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :user/xp 4}\n   ])&quot;, :offset 149, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n\n\n\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     [username])lb)])\n  )\n\n\n(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             {:user/username username\n              :delta (- old-r new-r)}))\n         (keys new-ranks))))\n\n(defn leaderboard [db period date]\n\n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 3190, :ns &quot;project.api-test&quot;} {:command &quot;(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     [username])lb)]\n    names)\n  )&quot;, :offset 125, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     username)lb)]\n    names)\n  )&quot;, :offset 123, :ns &quot;project.leaderboard&quot;} {:command &quot;(get-all-names (leaderboard (d/db conn) :all (LocalDate/now)))&quot;, :offset 62, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn new-user-check [old-names new-names]\n  (if (= old-names new-names) 10) 20)&quot;, :offset 80, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn new-user-check [old-names new-names]\n  (if (= (get-all-names old-names) (get-all-names new-names)) 10) 20)&quot;, :offset 112, :ns &quot;project.leaderboard&quot;} {:command &quot;(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; 20)&quot;, :offset 75, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; 10)&quot;, :offset 75, :ns &quot;project.api-test&quot;} {:command &quot;(defn new-user-check [old-names new-names]\n  (filter (complement old-names) new-names)\n)&quot;, :offset 88, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :user/xp 4}\n   ])\n(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n\n   ])\n\n(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)\n(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )\n\n(defn new-user-check [old-names new-names]\n  (filter (complement old-names) new-names)\n)\n\n(fact \&quot;test leaderboard unit fn\&quot;\n      (let []))\n\n\n\n&quot;, :offset 1321, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn new-user-check [old-lb new-lb]\n  (let [old-names (lb/get-all-names old-lb) new-names (lb/get-all-names new-lb)]\n    (filter (complement old-names) new-names))\n  \n)&quot;, :offset 169, :ns &quot;project.api-test&quot;} {:command &quot;(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(lb/get-all-names old-lb)) new-names (set(lb/get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n\n)&quot;, :offset 177, :ns &quot;project.api-test&quot;} {:command &quot;(lb/get-all-names old-lb)&quot;, :offset 25, :ns &quot;project.api-test&quot;} {:command &quot;(new-user-check old-lb new-lb)&quot;, :offset 29, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n            \n               {:user/username username\n                :delta (- old-r new-r)}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n             ))\n         (keys new-ranks)))&quot;, :offset 716, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :user/xp 4}\n   ])\n(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n\n   ])\n\n(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)\n(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )\n\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(lb/get-all-names old-lb)) new-names (set(lb/get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n\n)\n\n(fact \&quot;test leaderboard unit fn\&quot;\n      (let []))\n\n\n\n&quot;, :offset 1410, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               )\n             {:user/username username\n              :delta (- old-r new-r)}\n             )\n           ))\n    (keys new-ranks)))&quot;, :offset 1015, :ns &quot;project.leaderboard&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n\n\n\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     username)lb)]\n    names)\n  )\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(get-all-names old-lb)) new-names (set(get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n  )\n\n(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n\n               {:user/username username\n                :delta (- old-r new-r)}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n             ))\n         (keys new-ranks)))\n\n(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               )\n             {:user/username username\n              :delta (- old-r new-r)}\n             )\n           ))\n    (keys new-ranks)))\n\n\n(defn leaderboard [db period date]\n\n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 4503, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n               )\n             \n           ))\n    (keys new-ranks)))&quot;, :offset 1035, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n               )\n\n           ))\n    (keys new-ranks)))&quot;, :offset 1022, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (vec(map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n               )\n\n           )))\n    (keys new-ranks)))&quot;, :offset 1027, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (mapv (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n               )\n\n           )(keys new-ranks))\n    ))&quot;, :offset 1023, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (mapv (fn [username]\n            (let [old-r (get old-ranks username)\n                  new-r (get new-ranks username)]\n              (if (new-users username)\n                {:user/username username\n                 :delta (- (inc last-old-rank) new-r)\n                 :status \&quot;New\&quot;}\n                {:user/username username\n                 :delta (- old-r new-r)})))\n          (keys new-ranks))))&quot;, :offset 974, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)\n                 ]\n             (if (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status \&quot;New\&quot;}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n               )\n\n           )(keys new-ranks))\n    ))&quot;, :offset 1022, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             (cond\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status :new}\n               \n               (and old-r new-r)\n               {:user/username username\n                :delta (- old-r new-r)}\n               \n               :else\n               {:user/username username\n                :delta 0})))\n         (keys new-ranks))))&quot;, :offset 1132, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             (cond\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status :new}\n\n               (and old-r new-r)\n               {:user/username username\n                :delta (- old-r new-r)}\n\n               :else\n               {:user/username username\n                :delta 0})))\n         (keys new-ranks))))&quot;, :offset 1102, :ns &quot;project.leaderboard&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {}\n                        (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {}\n                        (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)]\n    (doall\n      (map (fn [username]\n             (let [old-r (get old-ranks username)\n                   new-r (get new-ranks username)]\n               (cond\n                 (nil? new-r)\n                 {:user/username username\n                  :delta 0\n                  :status :invalid}\n\n                 (new-users username)\n                 {:user/username username\n                  :delta (- (inc last-old-rank) new-r)\n                  :status :new}\n\n                 (number? old-r)\n                 {:user/username username\n                  :delta (- old-r new-r)}\n\n                 :else\n                 {:user/username username\n                  :delta 0})))\n           (keys new-ranks)))))\n&quot;, :offset 1307, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)]\n\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n\n             (cond\n               ;; Sluaj 1: Potpuno novi korisnik\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :old-rank nil\n                :new-rank new-r\n                :status \&quot;New\&quot;}\n\n               ;; Sluaj 2: Korisnik koji je pao sa liste (nema ga u novoj)\n               (nil? new-r)  ;; ovo ne bi trebalo da se desi sa tvojim kodom\n               {:user/username username\n                :delta (- old-r (inc last-old-rank))\n                :old-rank old-r\n                :new-rank nil\n                :status \&quot;Removed\&quot;}\n\n               ;; Sluaj 3: Normalno pomeranje\n               :else\n               {:user/username username\n                :delta (- old-r new-r)\n                :old-rank old-r\n                :new-rank new-r\n                :status \&quot;Moved\&quot;})))\n\n         (keys new-ranks))))&quot;, :offset 1596, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)]\n\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n\n             (cond\n               ;; Sluaj 1: Potpuno novi korisnik\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :old-rank nil\n                :new-rank new-r\n                :status \&quot;New\&quot;}\n\n               ;; Sluaj 2: Korisnik koji je bio u staroj, nema ga u novoj\n               ;; ALI OVO SE NIKAD NE DEAVA jer (keys new-ranks) sadri samo one koji SU u new-ranks!\n               (nil? new-r)\n               {:user/username username\n                :delta (- old-r (inc last-old-rank))\n                :old-rank old-r\n                :new-rank nil\n                :status \&quot;Removed\&quot;}\n\n               ;; Sluaj 3: Normalno pomeranje - STARO RANK POSTOJI!\n               (and old-r new-r)  ;; DODAJ OVU PROVERU!\n               {:user/username username\n                :delta (- old-r new-r)\n                :old-rank old-r\n                :new-rank new-r\n                :status \&quot;Moved\&quot;}\n\n               ;; Sluaj 4: Nekonzistentni podaci (trebalo bi da se desi)\n               :else\n               {:user/username username\n                :delta 0  ;; ili neka default vrednost\n                :old-rank old-r\n                :new-rank new-r\n                :status \&quot;Error\&quot;})))\n\n         (keys new-ranks))))&quot;, :offset 1994, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :user/xp 4}\n   ])\n(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n\n   ])\n()\n(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)\n(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )\n\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(lb/get-all-names old-lb)) new-names (set(lb/get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n\n)\n\n(fact \&quot;test leaderboard unit fn\&quot;\n      (let []))\n\n\n\n&quot;, :offset 1412, :ns &quot;project.api-test&quot;} {:command &quot;(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     username)lb)]\n    names)\n  )\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(get-all-names old-lb)) new-names (set(get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n  )\n&quot;, :offset 297, :ns &quot;project.leaderboard&quot;} {:command &quot;(lb/leaderboard-delta-edge-case old-lb new-lb)&quot;, :offset 45, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n\n\n\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     username)lb)]\n    names)\n  )\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(get-all-names old-lb)) new-names (set(get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n  )\n\n(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n\n               {:user/username username\n                :delta (- old-r new-r)}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n             ))\n         (keys new-ranks)))\n\n(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             (cond\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                :status :new}\n\n               (and old-r new-r)\n               {:user/username username\n                :delta (- old-r new-r)}\n\n               :else\n               {:user/username username\n                :delta 0})))\n         (keys new-ranks))))\n\n\n(defn leaderboard [db period date]\n\n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 4590, :ns &quot;project.core&quot;} {:command &quot;(ns project.db\n  (:require [datomic.api :as d]\n            [clojure.string :as str]\n            [project.time :as t]\n            [project.validation :as v]\n            [project.system :refer [conn]]\n            )\n  (:import (java.time LocalDate)))\n\n\n(defn create-user! [conn name]\n  (v/validate! v/CreateUserInput {:username name})\n  @(d/transact conn [{:user/username name\n                      :user/xp 0\n                      }]))\n\n(defn add-activity! [conn username activity-key duration intensity]\n  (v/validate! v/AddActivityInput {:username username\n                                   :activity-type activity-key\n                                   :duration duration\n                                   :intensity intensity})\n  @(d/transact conn [[:activity/add username activity-key duration intensity]]))\n\n\n(defn user-ids [db] (d/q '[:find ?e .\n                     :where [?e :user/username]] db))\n\n(defn get-all-users [db] (map first (d/q '[:find (pull ?e [*])\n                     :where [?e :user/username]] db)))\n\n(defn get-user-by-name [db username]\n  (let [result (d/pull db \&quot;[*]\&quot; [:user/username username])]\n    (if (:db/id result) result (throw (ex-info \&quot;User not found\&quot; {:user/username username})  ))\n    ))\n\n(defn get-user-activities [db username]\n  (d/q '[:find ?a-start-time ?a-type ?a-duration ?a-intensity ?xp-per-min\n         :in $ ?username\n         :where  [?u :user/username ?username]\n         [?a :activity/user ?u]\n         [?a :activity/type ?t]\n         [?t :activity-type/name ?a-type]\n         [?a :activity/intensity ?a-intensity ]\n         [?a :activity/duration ?a-duration]\n         [?t :activity-type/xp-per-minute ?xp-per-min]\n         [?a :activity/start-time ?a-start-time ]\n         ] db username))\n\n(defn get-activities-in-interval\n  [db username start-day end-day]\n  (d/q '[:find ?start-time ?type-name ?dur ?int ?xp-per-min\n         :in $ ?username ?start ?end\n         :where\n         [?u :user/username ?username]\n         [?a :activity/user ?u]\n         [?a :activity/start-time ?start-time]\n         [?a :activity/duration ?dur]\n         [?a :activity/intensity ?int]\n         [?a :activity/type ?t]\n         [?t :activity-type/name ?type-name]\n         [?t :activity-type/xp-per-minute ?xp-per-min]\n         [(&gt;= ?start-time ?start)]\n         [(&lt; ?start-time ?end)]]\n       db username start-day end-day))\n\n(defn calculate-xp-from-rows [rows]\n  (reduce (fn [total-xp [_ _ dur int xp-per-min]]\n            (+ total-xp (* dur int xp-per-min)))\n          0\n          rows))\n\n(def period-interval\n  {:daily t/day-interval\n   :weekly t/week-interval\n   :monthly t/month-interval\n   :all     nil})\n\n(defn add-xp [conn db username xp-to-add]\n  (let [[e current-xp]\n        (first (d/q '[:find ?e ?xp\n                      :in $ ?username\n                      :where [?e :user/username ?username]\n                      [?e :user/xp ?xp]\n                      ]\n                    db username))\n        new-xp (+ current-xp xp-to-add)]\n    @(d/transact conn [[:db/add e :user/xp new-xp]])\n    ))\n\n(def add-xp-tx {:db/ident :user/add-xp\n                :db/fn (d/function\n                         '{:lang \&quot;clojure\&quot;\n                          :params [db username xp]\n                          :code (let [[e current-xp]\n                                      (first (d/q '[:find ?e ?xp\n                                                    :in $ ?username\n                                                    :where [?e :user/username ?username]\n                                                    [?e :user/xp ?xp]\n                                                    ] db username))]\n                                  [[:db/add e :user/xp (+ current-xp xp)]])})})\n\n(def add-activity-tx\n  {:db/ident :activity/add\n   :db/fn (d/function\n            '{:lang \&quot;clojure\&quot;\n              :params [db username activity-type-key duration intensity]\n              :code (let [\n                          user-e\n                          (d/q '[:find ?e .\n                                 :in $ ?username\n                                 :where [?e :user/username ?username]]\n                               db username)\n                          [act-type-e xp-per-min]\n                          (first (d/q '[:find ?e ?xp-per-minute\n                                        :in $ ?type\n                                        :where [?e :activity-type/key ?type]\n                                        [?e :activity-type/xp-per-minute ?xp-per-minute]\n                                        ] db activity-type-key))\n                          gained-xp (* duration xp-per-min intensity)\n\n                          current-xp (or (:user/xp (d/entity db user-e)) 0)\n\n                          new-xp (+ current-xp gained-xp)\n                          activity-id (d/tempid :db.part/user)]\n                      [\n                       {:db/id activity-id\n                        :activity/user user-e\n                        :activity/type act-type-e\n                        :activity/duration duration\n                        :activity/intensity intensity\n                        :activity/start-time (java.util.Date.)\n                        }\n                       [:db/add user-e :user/xp new-xp\n                        ]])})})\n\n(def get-all-tx-functions [add-xp-tx add-activity-tx])\n\n(defn usernames-xp [db] (vec (d/q '[:find ?username ?xp\n                                    :where [?u :user/username ?username]\n                                    [?u :user/xp ?xp]] db)))\n\n(defn xp-per-user [db username period date]\n  ; slucaj kad je samo all\n  (if (= period :all)\n    (:user/xp (get-user-by-name db username))\n    ;---------------------\n    (let [{:keys [start-day end-day]} ((get period-interval period) date)\n          rows (get-activities-in-interval db username start-day end-day)]\n                        (calculate-xp-from-rows rows))))\n\n(defn report-daily-in-period [db username date]\n\n  ;total xp u danu\n  (let [{:keys [start-day end-day]} ((get period-interval :daily) date)\n        rows (get-activities-in-interval db username start-day end-day)\n        activities-xp (map (fn [[start-time a-type dur int xp-per-min]]\n                               {:activity/time (.toLocalTime (t/instant-&gt;local start-time))\n                                :activity/type a-type\n                                :activity/duration dur\n                                :activity/intensity int\n                                :activity/xp (* dur int xp-per-min)})rows)\n        total-xp (calculate-xp-from-rows rows)]\n\n    {\n     :date date\n     :username username\n     :activities activities-xp\n     :total-xp total-xp\n     }))\n\n(defn get-all-users)\n&quot;, :offset 6675, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :rank 4}\n   ])\n(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n\n   ])\n()\n(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)\n(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )\n\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(lb/get-all-names old-lb)) new-names (set(lb/get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n\n)\n\n(fact \&quot;test leaderboard unit fn\&quot;\n      (let []))\n\n\n\n&quot;, :offset 1409, :ns &quot;project.db&quot;} {:command &quot;(def old-lb\n  [{:user/username \&quot;A\&quot; :user/xp 1}\n   {:user/username \&quot;B\&quot; :user/xp 2}\n    {:user/username \&quot;C\&quot; :user/xp 3}\n   ])&quot;, :offset 123, :ns &quot;project.api-test&quot;} {:command &quot;(def new-lb\n  [{:user/username \&quot;A\&quot; :user/xp 2}\n   {:user/username \&quot;B\&quot; :user/xp 1}\n    {:user/username \&quot;C\&quot; :user/xp 3}\n   {:user/username \&quot;D\&quot; :user/xp 4}\n   ])&quot;, :offset 158, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )&quot;, :offset 73, :ns &quot;project.api-test&quot;} {:command &quot;(def old-lb\n  [{:user/username \&quot;A\&quot; :user/xp 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])&quot;, :offset 117, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)&quot;, :offset 205, :ns &quot;project.api-test&quot;} {:command &quot;(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 1}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :rank 4}\n   ])&quot;, :offset 146, :ns &quot;project.api-test&quot;} {:command &quot;(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 4}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :rank 1}\n   ])&quot;, :offset 146, :ns &quot;project.api-test&quot;} {:command &quot;(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])&quot;, :offset 114, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta-edge-case old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta 1 }\n      {:user/username \&quot;C\&quot; :delta 0 }]\n)&quot;, :offset 215, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n(let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                [username rank])\n                              old-lb))\n      new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                [username rank])\n                              new-lb))\n      new-users (set (new-user-check old-lb new-lb))\n      last-old-rank (if (seq old-ranks)\n                      (apply max (vals old-ranks))\n                      0)\n      ]\n    (fn [username]\n      (if (new-users username) username) false)))&quot;, :offset 350, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta-edge-case old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta -2 }\n      {:user/username \&quot;C\&quot; :delta 0 }\n      {:user/username \&quot;D\&quot; :delta 3 }]\n)&quot;, :offset 253, :ns &quot;project.api-test&quot;} {:command &quot;(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             (cond\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                }\n\n               (and old-r new-r)\n               {:user/username username\n                :delta (- old-r new-r)}\n\n               :else\n               {:user/username username\n                :delta 0})))\n         (keys new-ranks))))&quot;, :offset 1090, :ns &quot;project.leaderboard&quot;} {:command &quot;(fn [old-lb new-lb]\n(let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                [username rank])\n                              old-lb))\n      new-users (set (new-user-check old-lb new-lb))\n      ]\n    (fn [username]\n      (if (new-users username) username false) )))&quot;, :offset 310, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.leaderboard\n  (:require [project.db :as db]\n            [datomic.api :as d]\n            [project.connection :refer [conn]]\n            [project.time :as t]\n            [clojure.pprint :refer [print-table]])\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n\n(defn desc [a b] ; nasao sam na guglu kako se sortira od najveceg ka najmanjem.\n  (compare b a))\n\n\n\n\n\n(defn leaderboard-rank-ties [db period date]\n  (let [users (db/get-all-users db)\n        users-with-xp (map (fn [user]\n                             {:user/username (:user/username user)\n                              :user/xp (db/xp-per-user db (:user/username user) period date)})\n                           users)\n        sorted-users-with-xp (sort-by :user/xp &gt; users-with-xp)\n        ]\n    (loop [users-left sorted-users-with-xp\n           result []\n           current-rank 1\n           prev-xp nil\n           same-count 0]\n      (if (empty? users-left)\n        result\n        (let [user (first users-left)\n              user-xp (:user/xp user)]\n          (if (= user-xp prev-xp)\n            (recur (rest users-left)\n                   (conj result (assoc user :rank current-rank))\n                   current-rank\n                   user-xp\n                   (inc same-count))\n            (let [new-rank (+ current-rank same-count)]\n              (recur (rest users-left)\n                     (conj result (assoc user :rank new-rank))\n                     new-rank\n                     user-xp\n                     1))))))))\n\n; leaderboard delta pokazuje koliko je koji user promenio rank\n(defn get-all-names [lb]\n  (let [names (map (fn [{:user/keys [username]}]\n                     username)lb)]\n    names)\n  )\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(get-all-names old-lb)) new-names (set(get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n  )\n\n(defn leaderboard-delta [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                               [username rank])\n                             new-lb))]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n\n               {:user/username username\n                :delta (- old-r new-r)}\n               {:user/username username\n                :delta (- old-r new-r)}\n               )\n             ))\n         (keys new-ranks)))\n\n(defn leaderboard-delta-edge-case [old-lb new-lb]\n  (let [old-ranks (into {} (map (fn[{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                old-lb))\n        new-ranks (into {} (map (fn [{:user/keys [username] :keys [rank]}]\n                                  [username rank])\n                                new-lb))\n        new-users (set (new-user-check old-lb new-lb))\n        last-old-rank (if (seq old-ranks)\n                        (apply max (vals old-ranks))\n                        0)\n        ]\n    (map (fn [username]\n           (let [old-r (get old-ranks username)\n                 new-r (get new-ranks username)]\n             (cond\n               (new-users username)\n               {:user/username username\n                :delta (- (inc last-old-rank) new-r)\n                }\n\n               (and old-r new-r)\n               {:user/username username\n                :delta (- old-r new-r)}\n\n               :else\n               {:user/username username\n                :delta 0})))\n         (keys new-ranks))))\n\n\n(defn leaderboard [db period date]\n\n  (let [\n        previous-date (case period\n                        :daily (.minusDays date 1)\n                        :weekly (.minusWeeks date 1)\n                        :monthly (.minusMonths date 1)\n                        date)\n        old-lb (leaderboard-rank-ties db period date)\n        new-lb (leaderboard-rank-ties db period previous-date)\n        delta (leaderboard-delta old-lb new-lb)\n        delta-map (into {} (map (fn [{:user/keys [username] :keys [delta]}]\n                                  [username delta])\n                                delta))\n        ]\n    (map (fn [user-rank]\n           (assoc user-rank :delta (get delta-map (:user/username user-rank) 0)))\n         new-lb)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n&quot;, :offset 4578, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId)))\n\n(def old-lb\n  [{:user/username \&quot;A\&quot; :rank 1}\n   {:user/username \&quot;B\&quot; :rank 2}\n    {:user/username \&quot;C\&quot; :rank 3}\n   ])\n(def new-lb\n  [{:user/username \&quot;A\&quot; :rank 2}\n   {:user/username \&quot;B\&quot; :rank 4}\n    {:user/username \&quot;C\&quot; :rank 3}\n   {:user/username \&quot;D\&quot; :rank 1}\n   ])\n(def users\n  [{:user/username \&quot;A\&quot; :user/xp 300}\n   {:user/username \&quot;B\&quot; :user/xp 200}\n    {:user/username \&quot;C\&quot; :user/xp 150}\n\n   ])\n()\n(fact \&quot;test delta funkcije\&quot;\n  (let [delta (lb/leaderboard-delta-edge-case old-lb new-lb)]\n    delta)\n  =&gt; [{:user/username \&quot;A\&quot; :delta -1 }\n      {:user/username \&quot;B\&quot; :delta -2 }\n      {:user/username \&quot;C\&quot; :delta 0 }\n      {:user/username \&quot;D\&quot; :delta 3 }]\n)\n\n(fact \&quot;New user check\&quot;\n      (lb/new-user-check old-lb new-lb)\n      =&gt; )\n\n(defn new-user-check [old-lb new-lb]\n  (let [old-names (set(lb/get-all-names old-lb)) new-names (set(lb/get-all-names new-lb))]\n    (filter (complement old-names) new-names))\n\n)\n\n(fact \&quot;test leaderboard unit fn\&quot;\n      (let []))\n\n\n\n&quot;, :offset 1458, :ns &quot;project.leaderboard&quot;} {:command &quot;(def fake-db\n  {:users\n   users})&quot;, :offset 33, :ns &quot;project.api-test&quot;} {:command &quot;fake-db&quot;, :offset 7, :ns &quot;project.api-test&quot;} {:command &quot;(fact \&quot;test leaderboard unit fn\&quot;\n      (let [db fake-db\n            ]\n        (lb/leaderboard-rank-ties db :all (LocalDate/now)))\n      =&gt; {:users [#:user {:username \&quot;A\&quot;, :xp 300}\n                  #:user {:username \&quot;B\&quot;, :xp 200}\n                  #:user {:username \&quot;C\&quot;, :xp 150}]}\n      )&quot;, :offset 289, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            \n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId))\n  (:use 'clojure.test))&quot;, :offset 536, :ns &quot;project.api-test&quot;} {:command &quot;(ns project.api-test\n  (:require [midje.sweet :refer :all]\n            [project.db :as db]\n            [project.leaderboard :as lb]\n            [datomic.api :as d]\n            [database.schema :as schema]\n            [database.seed :as seed]\n            [project.api :as api]\n            \n            )\n  (:import (java.time.temporal TemporalAdjusters)\n           (java.util Date)\n           (java.time ZonedDateTime LocalDate ZoneId)\n           (java.time Instant LocalDate DayOfWeek MonthDay YearMonth ZoneId))\n  (:use clojure.test))&quot;, :offset 535, :ns &quot;project.api-test&quot;} {:command &quot;(deftest leaderboard-rank-ties-test\n  (with-redefs\n    [db/get-all-users\n     (fn [_] [{:user/username \&quot;A\&quot; :user/xp 300}\n              {:user/username \&quot;B\&quot; :user/xp 200}\n              {:user/username \&quot;C\&quot; :user/xp 150}\n              ])\n     db/xp-per-user\n     (fn [_ username _ _]\n       ({\&quot;A\&quot; 300\n         \&quot;B\&quot; 200\n         \&quot;C\&quot; 150} username))]\n    (let [result (lb/leaderboard-rank-ties nil :daily nil)]\n      (is (= result\n             [{:user/username \&quot;A\&quot; :user/xp 300 :rank 1}\n              {:user/username \&quot;B\&quot; :user/xp 200 :rank 2}\n              {:user/username \&quot;C\&quot; :user/xp 150  :rank 3}])))))&quot;, :offset 598, :ns &quot;project.api-test&quot;} {:command &quot;(deftest leaderboard-rank-ties-test\n  (with-redefs\n    [project.db/get-all-users\n     (fn [_]\n       [{:user/username \&quot;A\&quot;}\n        {:user/username \&quot;B\&quot;}\n        {:user/username \&quot;C\&quot;}])\n\n     project.db/xp-per-user\n     (fn [_ username _ _]\n       ({\&quot;A\&quot; 300 \&quot;B\&quot; 200 \&quot;C\&quot; 150} username))]\n\n    (is (= (lb/leaderboard-rank-ties ::db :daily ::date)\n           [{:user/username \&quot;A\&quot; :user/xp 300 :rank 1}\n            {:user/username \&quot;B\&quot; :user/xp 200 :rank 2}\n            {:user/username \&quot;C\&quot; :user/xp 150 :rank 3}]))))&quot;, :offset 508, :ns &quot;project.api-test&quot;} {:command &quot;(leaderboard-rank-ties-test)&quot;, :offset 27, :ns &quot;project.api-test&quot;} {:command &quot;(ns web.server\n  (:require [project.api :as api]\n            [ring.adapter.jetty :as jetty]\n            [reitit.ring :as ring]\n            [hiccup.page :refer [html5]\n             ]\n          )\n  )&quot;, :offset 197, :ns &quot;project.core&quot;}], :remote []}}</component>
  <component name="RunManager" selected="Clojure REPL.REPL for ProjectV1">
    <configuration default="true" type="Babashka" factoryName="BabashkaLocalRepl" activateToolWindowBeforeRun="false">
      <setting name="displayName" value="" />
      <setting name="bbPath" value="" />
      <setting name="parameters" value="" />
      <option name="PARENT_ENVS" value="true" />
      <setting name="workingDir" value="" />
      <setting name="focusEditor" value="false" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration name="REPL for ProjectV1" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <option name="configVersion" value="1" />
      <option name="displayName" value="REPL for ProjectV1" />
      <option name="execution" value="LEININGEN" />
      <module name="ProjectV1" />
      <option name="options" />
      <option name="profiles" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <option name="configVersion" value="1" />
      <option name="options" />
      <option name="profiles" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="displayName" value="" />
      <setting name="host" value="" />
      <setting name="port" value="0" />
      <setting name="replType" value="SOCKET" />
      <setting name="configType" value="SPECIFY" />
      <setting name="replPortFileType" value="STANDARD" />
      <setting name="customPortFile" value="" />
      <setting name="fixLineNumbers" value="false" />
      <setting name="useHeartbeat" value="true" />
      <setting name="focusEditor" value="false" />
      <setting name="urlFile" value="" />
      <method v="2" />
    </configuration>
    <configuration name="Test project.api-test/delta-test" type="ClojureTestRunConfiguration" factoryName="clojure.test" temporary="true">
      <module name="ProjectV1" />
      <option name="selector" value="SINGLE_VAR" />
      <option name="varFqn" value="project.api-test/delta-test" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <configuration name="Test project.api-test/leaderboard-rank-ties-test" type="ClojureTestRunConfiguration" factoryName="clojure.test" temporary="true">
      <module name="ProjectV1" />
      <option name="selector" value="SINGLE_VAR" />
      <option name="varFqn" value="project.api-test/leaderboard-rank-ties-test" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <method v="2" />
    </configuration>
    <recent_temporary>
      <list>
        <item itemvalue="clojure.test.Test project.api-test/delta-test" />
        <item itemvalue="clojure.test.Test project.api-test/leaderboard-rank-ties-test" />
      </list>
    </recent_temporary>
  </component>
  <component name="SharedIndexes">
    <attachedChunks>
      <set>
        <option value="bundled-jdk-9823dce3aa75-fbdcb00ec9e3-intellij.indexing.shared.core-IU-251.25410.129" />
        <option value="bundled-js-predefined-d6986cc7102b-6a121458b545-JavaScript-IU-251.25410.129" />
      </set>
    </attachedChunks>
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="4d338447-6f3a-43e8-ab8c-95e214f36644" name="Changes" comment="" />
      <created>1767121985479</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1767121985479</updated>
      <workItem from="1767121986415" duration="3674000" />
      <workItem from="1767181139032" duration="1494000" />
      <workItem from="1767351215899" duration="6476000" />
      <workItem from="1767379148928" duration="2673000" />
      <workItem from="1767381868455" duration="67000" />
      <workItem from="1767472762290" duration="1088000" />
      <workItem from="1767537145030" duration="11000" />
      <workItem from="1767625268145" duration="5102000" />
      <workItem from="1767694847080" duration="18149000" />
      <workItem from="1767804228503" duration="9080000" />
      <workItem from="1767892649731" duration="8974000" />
      <workItem from="1767906416609" duration="6067000" />
      <workItem from="1767958972899" duration="595000" />
      <workItem from="1768070963735" duration="14388000" />
      <workItem from="1768129866250" duration="9988000" />
      <workItem from="1768149678456" duration="13189000" />
      <workItem from="1768171748332" duration="36000" />
      <workItem from="1768403682096" duration="4369000" />
      <workItem from="1768474526888" duration="8177000" />
      <workItem from="1768491610839" duration="3377000" />
      <workItem from="1768587661011" duration="10613000" />
      <workItem from="1768638813832" duration="14723000" />
      <workItem from="1768662775460" duration="5330000" />
      <workItem from="1768736915225" duration="291000" />
      <workItem from="1768771507620" duration="5414000" />
      <workItem from="1768808685053" duration="10422000" />
      <workItem from="1768828344403" duration="6339000" />
      <workItem from="1768841963659" duration="9097000" />
      <workItem from="1768919011338" duration="96000" />
      <workItem from="1769022282280" duration="7836000" />
      <workItem from="1769075977686" duration="8791000" />
      <workItem from="1769089486580" duration="5158000" />
      <workItem from="1769124897316" duration="72000" />
      <workItem from="1769184242641" duration="3047000" />
      <workItem from="1769250460539" duration="3000" />
      <workItem from="1769333055758" duration="3673000" />
      <workItem from="1769361640551" duration="9538000" />
    </task>
    <task id="LOCAL-00001" summary="Ucitan je Datomic, sad vezbam koriscenje kroz dokumentaciju">
      <option name="closed" value="true" />
      <created>1767125847824</created>
      <option name="number" value="00001" />
      <option name="presentableId" value="LOCAL-00001" />
      <option name="project" value="LOCAL" />
      <updated>1767125847824</updated>
    </task>
    <task id="LOCAL-00002" summary="Dodate neke default funkcije koje rade sa bazom u datomicu">
      <option name="closed" value="true" />
      <created>1767367199446</created>
      <option name="number" value="00002" />
      <option name="presentableId" value="LOCAL-00002" />
      <option name="project" value="LOCAL" />
      <updated>1767367199446</updated>
    </task>
    <task id="LOCAL-00003" summary="Uradjene kreiraj korisnika i dodaj xp u bazi">
      <option name="closed" value="true" />
      <created>1767381886292</created>
      <option name="number" value="00003" />
      <option name="presentableId" value="LOCAL-00003" />
      <option name="project" value="LOCAL" />
      <updated>1767381886292</updated>
    </task>
    <task id="LOCAL-00004" summary="Uradjene kreiraj korisnika i dodaj xp u bazi 2">
      <option name="closed" value="true" />
      <created>1767483540530</created>
      <option name="number" value="00004" />
      <option name="presentableId" value="LOCAL-00004" />
      <option name="project" value="LOCAL" />
      <updated>1767483540530</updated>
    </task>
    <task id="LOCAL-00005" summary="Provezbana funkcija add-xp">
      <option name="closed" value="true" />
      <created>1767634382925</created>
      <option name="number" value="00005" />
      <option name="presentableId" value="LOCAL-00005" />
      <option name="project" value="LOCAL" />
      <updated>1767634382925</updated>
    </task>
    <task id="LOCAL-00006" summary="transakciona funkcija koja dodaje xp useru, kreirana sema aktivnosti/event koje user izvrsava da bi dobio xp, &#10;kreirana sema tipa aktivnosti koja ima main tip aktivnosti.&#10;odvajam kod u dva paketa db i main paket, &#10;i db.clj u dva fajla schema.clj, seed.clj gde cu imati back ako mi se nesto zezne kao na primer da ubacim dva worka...">
      <option name="closed" value="true" />
      <created>1767734960862</created>
      <option name="number" value="00006" />
      <option name="presentableId" value="LOCAL-00006" />
      <option name="project" value="LOCAL" />
      <updated>1767734960862</updated>
    </task>
    <task id="LOCAL-00007" summary="transakciona funkcija koja dodaje xp useru, kreirana sema aktivnosti/event koje user izvrsava da bi dobio xp, &#10;kreirana sema tipa aktivnosti koja ima main tip aktivnosti.&#10;odvajam kod u dva paketa db i main paket, &#10;i db.clj u dva fajla schema.clj, seed.clj gde cu imati back ako mi se nesto zezne kao na primer da ubacim dva worka...">
      <option name="closed" value="true" />
      <created>1767734966394</created>
      <option name="number" value="00007" />
      <option name="presentableId" value="LOCAL-00007" />
      <option name="project" value="LOCAL" />
      <updated>1767734966394</updated>
    </task>
    <task id="LOCAL-00008" summary="Uh, datomic je malo naporan iskreno, ali zanimljiv jer je sve kao u clojuru. Odvojio sam scheme i seed, pohvatao sam fazon sa transakcijama, i kako se sta pise">
      <option name="closed" value="true" />
      <created>1767742945250</created>
      <option name="number" value="00008" />
      <option name="presentableId" value="LOCAL-00008" />
      <option name="project" value="LOCAL" />
      <updated>1767742945250</updated>
    </task>
    <task id="LOCAL-00009" summary="Kreirana funkcija activity/add, sustina app, na osnovu parametara se izracuna xp za odredjenu aktivnost">
      <option name="closed" value="true" />
      <created>1767812289892</created>
      <option name="number" value="00009" />
      <option name="presentableId" value="LOCAL-00009" />
      <option name="project" value="LOCAL" />
      <updated>1767812289893</updated>
    </task>
    <task id="LOCAL-00010" summary="Fixed add-activity-tx,&#10;user-activities -&gt; query for finding all activities of one user">
      <option name="closed" value="true" />
      <created>1767902122657</created>
      <option name="number" value="00010" />
      <option name="presentableId" value="LOCAL-00010" />
      <option name="project" value="LOCAL" />
      <updated>1767902122657</updated>
    </task>
    <task id="LOCAL-00011" summary="Daily activities by user - list of every activity done in one day.&#10;Daily-xp - user can be put in leaderboard to compete and compare daily activities with other people.">
      <option name="closed" value="true" />
      <created>1767915212637</created>
      <option name="number" value="00011" />
      <option name="presentableId" value="LOCAL-00011" />
      <option name="project" value="LOCAL" />
      <updated>1767915212637</updated>
    </task>
    <task id="LOCAL-00012" summary="Daily, Weekly and Monthly activities and xp per user">
      <option name="closed" value="true" />
      <created>1768083937606</created>
      <option name="number" value="00012" />
      <option name="presentableId" value="LOCAL-00012" />
      <option name="project" value="LOCAL" />
      <updated>1768083937606</updated>
    </task>
    <task id="LOCAL-00013" summary="Daily, Weekly and Monthly activities and xp per user">
      <option name="closed" value="true" />
      <created>1768085174478</created>
      <option name="number" value="00013" />
      <option name="presentableId" value="LOCAL-00013" />
      <option name="project" value="LOCAL" />
      <updated>1768085174478</updated>
    </task>
    <task id="LOCAL-00014" summary="Fixing old code, erasing and moving unnecessary and outdated functions. &#10;Setting up better architecture, more readable">
      <option name="closed" value="true" />
      <created>1768162612523</created>
      <option name="number" value="00014" />
      <option name="presentableId" value="LOCAL-00014" />
      <option name="project" value="LOCAL" />
      <updated>1768162612523</updated>
    </task>
    <task id="LOCAL-00015" summary="Testing of malli validation">
      <option name="closed" value="true" />
      <created>1768165269540</created>
      <option name="number" value="00015" />
      <option name="presentableId" value="LOCAL-00015" />
      <option name="project" value="LOCAL" />
      <updated>1768165269540</updated>
    </task>
    <task id="LOCAL-00016" summary="Malli validation, validate! function">
      <option name="closed" value="true" />
      <created>1768167032069</created>
      <option name="number" value="00016" />
      <option name="presentableId" value="LOCAL-00016" />
      <option name="project" value="LOCAL" />
      <updated>1768167032069</updated>
    </task>
    <task id="LOCAL-00017" summary="Validation of transaction function add-activity and create user">
      <option name="closed" value="true" />
      <created>1768169307460</created>
      <option name="number" value="00017" />
      <option name="presentableId" value="LOCAL-00017" />
      <option name="project" value="LOCAL" />
      <updated>1768169307460</updated>
    </task>
    <task id="LOCAL-00018" summary="Leaderboard for one day, week and month">
      <option name="closed" value="true" />
      <created>1768495590013</created>
      <option name="number" value="00018" />
      <option name="presentableId" value="LOCAL-00018" />
      <option name="project" value="LOCAL" />
      <updated>1768495590013</updated>
    </task>
    <task id="LOCAL-00019" summary="Leaderboard finito">
      <option name="closed" value="true" />
      <created>1768592793347</created>
      <option name="number" value="00019" />
      <option name="presentableId" value="LOCAL-00019" />
      <option name="project" value="LOCAL" />
      <updated>1768592793347</updated>
    </task>
    <task id="LOCAL-00020" summary="Leaderboard finito 2, merged daily, weekly, monthly leaderboard function in one function, all time leaderboard is still by itself">
      <option name="closed" value="true" />
      <created>1768600694449</created>
      <option name="number" value="00020" />
      <option name="presentableId" value="LOCAL-00020" />
      <option name="project" value="LOCAL" />
      <updated>1768600694449</updated>
    </task>
    <task id="LOCAL-00021" summary="Leaderboard finito 3, i merged even all-time in default leaderboard fn, so now code is clearer and less messy. Deleted unnecessary fucntion i no longer use. Added 3 tests for 2 for adding activity and 1 for leaderboard.">
      <option name="closed" value="true" />
      <created>1768661297153</created>
      <option name="number" value="00021" />
      <option name="presentableId" value="LOCAL-00021" />
      <option name="project" value="LOCAL" />
      <updated>1768661297153</updated>
    </task>
    <task id="LOCAL-00022" summary="API preparing for frontend, did some validation">
      <option name="closed" value="true" />
      <created>1768779315145</created>
      <option name="number" value="00022" />
      <option name="presentableId" value="LOCAL-00022" />
      <option name="project" value="LOCAL" />
      <updated>1768779315145</updated>
    </task>
    <task id="LOCAL-00023" summary="Leaderboard with rank and ties in xp">
      <option name="closed" value="true" />
      <created>1768833163143</created>
      <option name="number" value="00023" />
      <option name="presentableId" value="LOCAL-00023" />
      <option name="project" value="LOCAL" />
      <updated>1768833163143</updated>
    </task>
    <task id="LOCAL-00024" summary="Leaderboard delta, calculate changes in rank">
      <option name="closed" value="true" />
      <created>1768855602635</created>
      <option name="number" value="00024" />
      <option name="presentableId" value="LOCAL-00024" />
      <option name="project" value="LOCAL" />
      <updated>1768855602635</updated>
    </task>
    <task id="LOCAL-00025" summary="Leaderboard delta still">
      <option name="closed" value="true" />
      <created>1768859643777</created>
      <option name="number" value="00025" />
      <option name="presentableId" value="LOCAL-00025" />
      <option name="project" value="LOCAL" />
      <updated>1768859643777</updated>
    </task>
    <task id="LOCAL-00026" summary="Leaderboard delta test, edge case -&gt; when new user is added, how he evaluate,&#10;I failed today, it needs fix tomorrow.">
      <option name="closed" value="true" />
      <created>1769039313571</created>
      <option name="number" value="00026" />
      <option name="presentableId" value="LOCAL-00026" />
      <option name="project" value="LOCAL" />
      <updated>1769039313571</updated>
    </task>
    <task id="LOCAL-00027" summary="Leaderboard delta test, edge case -&gt; when new user is added, how he evaluate,&#10;Fixed, problem was in test data">
      <option name="closed" value="true" />
      <created>1769078211847</created>
      <option name="number" value="00027" />
      <option name="presentableId" value="LOCAL-00027" />
      <option name="project" value="LOCAL" />
      <updated>1769078211847</updated>
    </task>
    <task id="LOCAL-00028" summary="Change to clojure.test, done 2 tests">
      <option name="closed" value="true" />
      <created>1769124957289</created>
      <option name="number" value="00028" />
      <option name="presentableId" value="LOCAL-00028" />
      <option name="project" value="LOCAL" />
      <updated>1769124957289</updated>
    </task>
    <option name="localTasksCounter" value="29" />
    <servers />
  </component>
  <component name="TypeScriptGeneratedFilesManager">
    <option name="version" value="3" />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State />
          </value>
        </entry>
      </map>
    </option>
  </component>
  <component name="VcsManagerConfiguration">
    <MESSAGE value="Uradjene kreiraj korisnika i dodaj xp u bazi" />
    <MESSAGE value="Uradjene kreiraj korisnika i dodaj xp u bazi 2" />
    <MESSAGE value="Provezbana funkcija add-xp" />
    <MESSAGE value="transakciona funkcija koja dodaje xp useru, kreirana sema aktivnosti/event koje user izvrsava da bi dobio xp, &#10;kreirana sema tipa aktivnosti koja ima main tip aktivnosti" />
    <MESSAGE value="transakciona funkcija koja dodaje xp useru, kreirana sema aktivnosti/event koje user izvrsava da bi dobio xp, &#10;kreirana sema tipa aktivnosti koja ima main tip aktivnosti.&#10;odvajam kod u dva paketa db i main paket, &#10;i db.clj u dva fajla schema.clj, seed.clj gde cu imati back ako mi se nesto zezne kao na primer da ubacim dva worka..." />
    <MESSAGE value="Uh, datomic je malo naporan iskreno, ali zanimljiv jer je sve kao u clojuru. Odvojio sam scheme i seed, pohvatao sam fazon sa transakcijama, i kako se sta pise" />
    <MESSAGE value="Kreirana funkcija activity/add, sustina app, na osnovu parametara se izracuna xp za odredjenu aktivnost" />
    <MESSAGE value="Fixed add-activity-tx,&#10;user-activities -&gt; query for finding all activities of one user" />
    <MESSAGE value="Daily activities by user - list of every activity done in one day.&#10;Daily-xp - user can be put in leaderboard to compete and compare daily activities with other people." />
    <MESSAGE value="Daily, Weekly and Monthly activities and xp per user" />
    <MESSAGE value="Fixing old code, erasing and moving unnecessary and outdated functions. &#10;Setting up better architecture, more readable" />
    <MESSAGE value="Testing of malli validation" />
    <MESSAGE value="Malli validation, validate! function" />
    <MESSAGE value="Validation of transaction function add-activity and create user" />
    <MESSAGE value="Leaderboard for one day, week and month" />
    <MESSAGE value="Leaderboard finito" />
    <MESSAGE value="Leaderboard finito 2, merged daily, weekly, monthly leaderboard function in one function, all time leaderboard is still by itself" />
    <MESSAGE value="Leaderboard finito 3, i merged even all-time in default leaderboard fn, so now code is clearer and less messy. Deleted unnecessary fucntion i no longer use. Added 3 tests for 2 for adding activity and 1 for leaderboard." />
    <MESSAGE value="API preparing for frontend, did some validation" />
    <MESSAGE value="Leaderboard with rank and ties in xp" />
    <MESSAGE value="Leaderboard delta, calculate changes in rank" />
    <MESSAGE value="Leaderboard delta still" />
    <MESSAGE value="Leaderboard delta test, edge case -&gt; when new user is added, how he evaluate,&#10;I failed today, it needs fix tomorrow." />
    <MESSAGE value="Leaderboard delta test, edge case -&gt; when new user is added, how he evaluate,&#10;Fixed, problem was in test data" />
    <MESSAGE value="Change to clojure.test, done 2 tests" />
    <option name="LAST_COMMIT_MESSAGE" value="Change to clojure.test, done 2 tests" />
  </component>
</project>